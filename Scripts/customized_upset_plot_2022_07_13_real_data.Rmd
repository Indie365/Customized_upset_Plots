---
title: "Customized_upset_plot"
author: "Chenxin Li"
date: "07/13/2022"
output: 
  html_notebook:
    number_sections: yes
    toc: yes
    toc_float: yes
  html_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Dependencies 
If you have Tidyverse and cowplot you are mostly covered. 
If you want to save plot as .svg you may need the R package svglite.
If you are using Mac, you may need to install XQuart. [Link](https://www.xquartz.org/)  

```{r}
library(tidyverse) 
library(cowplot) 

library(RColorBrewer) # This is for the colors only, not actually necessary. 
```

cowplot is used to make composite plots. You can use patchwork too, if you prefer that. 

# Data
```{r}
data1_full <- read_csv("../Data/data1.csv", col_types = cols())  # Ovary siRNA loci
data2_full <- read_csv("../Data/data2.csv", col_types = cols())  # Egg siRNA loci
data3_full <- read_csv("../Data/data3.csv", col_types = cols())  # Seedling siRNA loci
data4_full <- read_csv("../Data/data4.csv", col_types = cols()) # Sperm siRNA loci 
```

`col_types = cols()` argument supresses column type specification messages. 

These are 4 different small RNA datasets. 
Data from [Li et al. 2020. Genome Research](https://www.ncbi.nlm.nih.gov/pubmed/31896557) 

* 1st column = genome location. This is what we'll find intersection for.
* 2nd column = their small RNA relative abundance (expression), in units of RPM.
* last column = cell type.

we'll ignore the rest of the columns.

Let's rename the columns to match the code 
Or you can edit the code to match your colnames 
We'll use the location col to find intersections first
We'll worry about their expression in different cell types later

```{r}
data1 <- data1_full %>% 
  mutate(elements = location) %>% 
  select(elements)

data2 <- data2_full %>% 
  mutate(elements = location) %>% 
  select(elements)

data3 <- data3_full %>% 
  mutate(elements = location) %>% 
  select(elements)

data4 <- data4_full %>% 
  mutate(elements = location) %>% 
  select(elements)
```


# Create set list object
```{r}
set_list <- list(data1, data2, data3, data4)
```

The order of sets in the list matters. In this case: 

1. data1 (Ovary)
2. data2 (Egg)
3. data3 (Seedling)
4. data4 (Sperm)

# Find specifics 
You can write a loop or something (apply or something in purr) to achieve all these 

```{r}
data1_specific <- setdiff(set_list[[1]]$elements, set_list[[2]]$elements) %>% 
  setdiff(set_list[[3]]$elements) %>% 
  setdiff(set_list[[4]]$elements)

data2_specific <- setdiff(set_list[[2]]$elements, set_list[[3]]$elements) %>% 
  setdiff(set_list[[4]]$elements) %>% 
  setdiff(set_list[[1]]$elements)

data3_specific <- setdiff(set_list[[3]]$elements, set_list[[4]]$elements) %>% 
  setdiff(set_list[[1]]$elements) %>% 
  setdiff(set_list[[2]]$elements)

data4_specific <- setdiff(set_list[[4]]$elements, set_list[[1]]$elements) %>% 
  setdiff(set_list[[2]]$elements) %>% 
  setdiff(set_list[[3]]$elements)
```



```{r}
ndata1_spec <- data1_specific %>% length()
ndata2_spec <- data2_specific %>% length()
ndata3_spec <- data3_specific %>% length()
ndata4_spec <- data4_specific %>% length()

# The above 2 chunks can be simplified by adding %>% length() to the previous code chunk. 
# However, if you want examine the elements in each intersections, I'd recommend take length() later 
```


# Find overlaps 
Note that in this version of customized upset plots, the intersections are now 'exclusive'. 
E.g., in sets A, B, C, D, 
2way(AB) = intersect(A,B) %>% setdiff(C) %>% setdiff(D) 
3way(ABC) = intersect(A,B) %>% intersect(C) %>% setdiff(D)  

## 2-way intersections 
```{r}
# In your data, the col name won't be "element". Change it here.  

data1by2 <- intersect(set_list[[1]]$elements, set_list[[2]]$elements) %>% 
  setdiff(set_list[[3]]$elements) %>% 
  setdiff(set_list[[4]]$elements)

data1by3 <- intersect(set_list[[1]]$elements, set_list[[3]]$elements) %>% 
  setdiff(set_list[[2]]$elements) %>% 
  setdiff(set_list[[4]]$elements)

data1by4 <- intersect(set_list[[1]]$elements, set_list[[4]]$elements) %>% 
  setdiff(set_list[[2]]$elements) %>% 
  setdiff(set_list[[3]]$elements)

data2by3 <- intersect(set_list[[2]]$elements, set_list[[3]]$elements) %>% 
  setdiff(set_list[[1]]$elements) %>% 
  setdiff(set_list[[4]]$elements)

data2by4 <- intersect(set_list[[2]]$elements, set_list[[4]]$elements) %>% 
  setdiff(set_list[[1]]$elements) %>% 
  setdiff(set_list[[3]]$elements)

data3by4 <- intersect(set_list[[3]]$elements, set_list[[4]]$elements) %>% 
  setdiff(set_list[[1]]$elements) %>% 
  setdiff(set_list[[2]]$elements)
```

```{r}
ndata1by2 <- length(data1by2)
ndata1by3 <- length(data1by3)
ndata1by4 <- length(data1by4)

ndata2by3 <- length(data2by3)
ndata2by4 <- length(data2by4)

ndata3by4 <- length(data3by4)
```

## 3-way intersections 
```{r}
# In your data, the col name won't be "element". Change it here.

data1by2by3 <- intersect(set_list[[1]]$elements, set_list[[2]]$elements) %>% 
  intersect(set_list[[3]]$elements) %>% 
  setdiff(set_list[[4]]$elements)

data2by3by4 <- intersect(set_list[[2]]$elements, set_list[[3]]$elements) %>% 
  intersect(set_list[[4]]$elements) %>% 
  setdiff(set_list[[1]]$elements)

data3by4by1 <- intersect(set_list[[3]]$elements, set_list[[4]]$elements) %>% 
  intersect(set_list[[1]]$elements) %>% 
  setdiff(set_list[[2]]$elements)

data4by1by2 <- intersect(set_list[[4]]$elements, set_list[[1]]$elements) %>% 
  intersect(set_list[[2]]$elements) %>% 
  setdiff(set_list[[3]]$elements)
```


```{r}
ndata1by2by3 <- data1by2by3 %>% length()
ndata2by3by4 <- data2by3by4 %>% length()
ndata3by4by1 <- data3by4by1 %>% length()
ndata4by1by2 <- data4by1by2 %>% length()
```

## 4-way intersection 
```{r}
# the highest order of overlap in this example is 4-way intersection, 
# which is commonly the largest in most of the Venn Diagrams... 
# You can go further beyond w/ upset plots if you like. 

data1by2by3by4 <- intersect(set_list[[1]]$elements, set_list[[2]]$elements) %>% 
  intersect(set_list[[3]]$elements) %>% 
  intersect(set_list[[4]]$elements)

ndata1by2by3by4 <- data1by2by3by4 %>% length()
```

# Total set size
```{r}
total <- data.frame(
  "sets" = c("ovary", "egg", "seedling", "sperm"),
  "sizes" = c(nrow(data1), nrow(data2), nrow(data3), nrow(data4))
) %>% 
  mutate(sets = factor(sets, levels = c(  # ovary is data1, egg is data2, seedling is data3, sperm is data4
    "ovary", "egg", "seedling", "sperm"   # so I reordered them. 
  )))

total # This will be the basis for the upperleft bar plot 
```


```{r}
upperleft <- total %>% 
  ggplot(aes(x = sets, y= sizes)) +
  geom_hline(yintercept = -Inf, size = 1.5) +
  geom_vline(xintercept = -Inf, size = 1.5) +
  geom_bar(stat = "identity", aes(fill = sets), alpha = 0.8, width = 0.7) +
  geom_text(aes(label = as.character(sizes)), size = 5, angle = 90, hjust = 0, y = 1, fontface = "bold") +
  scale_fill_manual(values = c("orangered3", "tomato1", "seagreen", "dodgerblue2"),  
                     limits = c("ovary", "egg", "seedling", "sperm")) + 
                                                  #feel free to use some other colors      
  scale_x_discrete(labels = NULL) +
  scale_y_continuous(labels = NULL) +
  labs(x = NULL,
       y = "Set size") +
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size= 14, face="bold"),
        axis.text.x=element_text(colour = "black", angle = 45, hjust = 1),
        axis.text.y=element_text(colour = "black"), 
        panel.grid = element_blank()
        ) 

upperleft
```
# Produce the legend 
the legend will show up at upper right 
```{r}
upperright <- get_legend(
  total %>% 
  ggplot(aes(x = sets, y= sizes)) +
  geom_hline(yintercept = -Inf, size = 1.5) +
  geom_vline(xintercept = -Inf, size = 1.5) +
  geom_bar(stat = "identity", aes(fill = sets), alpha = 0.8, width = 0.7) +
  geom_text(aes(label = as.character(sizes)), size = 5, angle = 90, hjust = 0, y = 1, fontface = "bold") +
  scale_fill_manual(values = c("orangered3", "tomato1", "seagreen", "dodgerblue2"),  
                     limits = c("ovary", "egg", "seedling", "sperm")) + 
                                                  #feel free to use some other colors      
  scale_x_discrete(labels = NULL) +
  scale_y_continuous(labels = NULL) +
  labs(x = NULL,
       y = "Set size",
       fill = "siRNA loci") +
  theme_minimal() +
  theme(legend.position = "right",
        text = element_text(size= 14, face="bold"),
        axis.text.x=element_text(colour = "black", angle = 45, hjust = 1),
        axis.text.y=element_text(colour = "black"), 
        panel.grid = element_blank()
        )  
)

# Same code as upper left, but w/ legend.position = right to get the legend   
plot_grid(upperright)
```

# Overlap matrix
```{r}
sets <- c("1", "2", "3", "4")
category <- c(
    "data1_specific",
    "data2_specific",
    "data3_specific",
    "data4_specific",
    "data1by2", 
    "data1by3",
    "data1by4",
    "data2by3",
    "data2by4",
    "data3by4",
    "data1by2by3",
    "data2by3by4",
    "data3by4by1",
    "data4by1by2",
    "data1by2by3by4" 
    )

overlap_matrix <- expand.grid(  # generate all the combinations 
  "sets" = sets,
  "category" = category
) %>% 
  as.data.frame()  %>%    # determine the intersection: a character col of Y or N. 
  mutate(intersect = case_when(
    str_detect(category, sets %>% as.character()) ~ "Y",
    T ~ "N"
  ))  

overlap_matrix
# this will be the bais for lower left plot 
```

```{r}
lowerleft <- overlap_matrix %>% 
  mutate(category = factor(rev(category))) %>% 
  # in the colored matrix the first y value appears in the bottom, 
  # so the order need to be reversed 
  ggplot(aes(x = sets, y = category))+
  geom_tile(aes(fill = sets, alpha = intersect), color = "black", size = 1.5) +
  scale_fill_manual(values = c(    "orangered3", "tomato1", "seagreen", "dodgerblue2"), 
# feel free to use other colors 
                    limits = c("1", "2", "3", "4")) +
  scale_alpha_manual(values = c(0.8, 0),  # color the grid for Y, don't color for N. 
                     limits = c("Y", "N")) +
  scale_x_discrete(labels = rep(" ", length(sets))) +
  # I left white space here for better alignment w/ extended plots 
  labs(x = " ", # White space for better alignment w/ right side plots 
       y = "Overlap") +
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size= 14, face="bold"),
        axis.text.y=element_blank(), 
        panel.grid = element_blank()
        )

lowerleft
```


# Lowerright  
```{r}
overlap_sizes <- data.frame(
  "overlap_sizes" = c(ndata1_spec, ndata2_spec, ndata3_spec, ndata4_spec, 
                      ndata1by2, ndata1by3, ndata1by4, ndata2by3, ndata2by4, ndata3by4, 
                      ndata1by2by3, ndata2by3by4, ndata3by4by1, ndata4by1by2,
                      ndata1by2by3by4),
  "category" = category 
) %>% 
  mutate(category = factor(category, levels = rev(category)))   # Again order needs to be reversed 

overlap_sizes # This will be the basis for bar plot at the lower right 
```

```{r}
lowerright <- overlap_sizes %>% 
  ggplot(aes(x = category, y = overlap_sizes)) +
  geom_bar(stat = "identity", fill = "grey80", color = NA, alpha = 0.8, width = 0.7) +
  geom_text(aes(label = overlap_sizes, y = 0), size = 5, hjust = 0, vjust = 0.5, fontface = "bold") +
  scale_y_continuous(breaks = c(0, max(overlap_sizes$overlap_sizes)) ,
                     labels = rep(" ", 2)) + # I left white space here for better alignment w/ extended plots
  labs(y = "Intersect sizes",
       x = NULL) +
  theme_minimal() +
  theme(text = element_text(size= 14, face="bold"),
        axis.text.y=element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line(),
        axis.title.x = element_text(hjust = 0),
        ) +
  coord_flip()

lowerright
```


# Put them all together
```{r}
plot_grid(upperleft, upperright, lowerleft, lowerright, 
          nrow = 2, 
          ncol = 2,
          rel_heights = c(1, 4), # the more rows in the lower part, the longer it should be
          rel_widths = c(1, 0.8))

ggsave("../Results/real_data_upset_full.svg", height = 7, width = 3.5, bg = "white") 
# this should be a tall & skinny plot 
# I prefer .svg, but you can also save as phd or png 
# I will open up the .svg file and mannually adjust the size until it's good
# check that nothing is cut off from the plot 
# png is for twitter posting 
ggsave("../Results/real_data_upset_full.png", height = 7, width = 3.5, bg = "white")
```

# Subsetting the inserctions
Say you are only interested in the overlaps w/ data3 

```{r}
lowerleft_3only <- overlap_matrix %>% 
  filter(str_detect(category, "by3|data3")) %>% # subset out things that overlaps w/ data3 
  mutate(category = factor(rev(category))) %>% 
  # in the colored matrix the first y value appears in the bottom, 
  # so the order need to be reversed 
  ggplot(aes(x = sets, y = category))+
  geom_tile(aes(fill = sets, alpha = intersect), color = "black", size = 1.5) +
  scale_fill_manual(values = c("orangered3", "tomato1", "seagreen", "dodgerblue2"), 
# feel free to use other colors 
                    limits = c("1", "2", "3", "4")) +
  scale_alpha_manual(values = c(0.8, 0),  # color the grid for Y, don't color for N. 
                     limits = c("Y", "N")) +
  scale_x_discrete(labels = rep(" ", length(sets))) +
  # I left white space here for better alignment w/ extended plots 
  labs(x = " ", # White space for better alignment w/ right side plots 
       y = "Overlap") +
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size= 14, face="bold"),
        axis.text.y=element_blank(), 
        panel.grid = element_blank()
        )
   
lowerleft_3only
```

```{r}
lowerright_3only <- overlap_sizes %>% 
  filter(str_detect(category, "by3|data3")) %>% # subset out things that overlaps w/ data3 
  ggplot(aes(x = category, y = overlap_sizes)) +
  geom_bar(stat = "identity", fill = "grey80", color = NA, alpha = 0.8, width = 0.7) +
  geom_text(aes(label = overlap_sizes, y = 0), size = 5, hjust = 0, vjust = 0.5, fontface = "bold") +
  scale_y_continuous(breaks = c(0, max(overlap_sizes$overlap_sizes)) ,
                     labels = rep(" ", 2)) + 
  # I left white space here for better alignment w/ extended plots
  labs(y = "Intersect sizes",
       x = NULL) +
  theme_minimal() +
  theme(text = element_text(size= 14, face="bold"),
        axis.text.y=element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line(),
        axis.title.x = element_text(hjust = 0),
        ) +
  coord_flip()

lowerright_3only
```


```{r}
plot_grid(upperleft, upperright, lowerleft_3only, lowerright_3only, 
          nrow = 2, 
          ncol = 2,
          rel_heights = c(1, 2.5), # this time the lower part can be shorter because there're less rows 
          rel_widths = c(0.9, 1))

ggsave("../Results/real_data_upset_3only.svg", height = 4.5, width = 3.5, bg = "white") 
# this time the plot can be shorter 
# the best aspect ratio is when the grids in the colored matrix are perfect squares 
ggsave("../Results/real_data_upset_3only.png", height = 4.5, width = 3.5, bg = "white") 
```


# Extensions
The right side of the upset plot can be extended. 
This works much better when you don't have any empty sets. 
Actually this ONLY works well when you don't have any empty sets.  

```{r}
# Do you have any empty sets? 
overlap_sizes %>% filter(overlap_sizes == 0)
```

```{r}
# We need to bring the expression and cell type info back 
full_data <- data1_full %>%  
  select(location, RPM) %>% 
  full_join(data2_full %>% 
              select(location, RPM), by = "location") %>% 
  full_join(data3_full %>% 
              select(location, RPM), by = "location") %>% 
  full_join(data4_full %>% 
              select(location, RPM), by = "location")

colnames(full_data) <- c("elements", "ovary", "egg", "seedling", "sperm") 
# you just have to change the colnames back to cell types by order

head(full_data)
```

 
```{r}
intersection_data <- rbind(
  data1_specific %>% 
    as.data.frame() %>% 
    mutate(category = "data1_specific"), 
  data2_specific %>% 
    as.data.frame() %>%
    mutate(category = "data2_specific"), 
  data3_specific %>% 
    as.data.frame() %>%
    mutate(category = "data3_specific"), 
  data4_specific %>% 
    as.data.frame() %>%
    mutate(category = "data4_specific"), 
  data1by2 %>%
    as.data.frame() %>%
    mutate(category = "data1by2"),
  data1by3 %>% 
    as.data.frame() %>%
    mutate(category = "data1by3"),
  data1by4 %>% 
    as.data.frame() %>%
    mutate(category = "data1by4"),
  data2by3 %>% 
    as.data.frame() %>% 
    mutate(category = "data2by3"),
  data2by4 %>% 
    as.data.frame() %>%
    mutate(category = "data2by4"),
  data3by4 %>% 
    as.data.frame() %>%
    mutate(category = "data3by4"),
  data1by2by3 %>% 
    as.data.frame() %>%
    mutate(category = "data1by2by3"),
  data2by3by4 %>% 
    as.data.frame() %>%
    mutate(category = "data2by3by4"),
  data3by4by1 %>% 
    as.data.frame() %>%
    mutate(category = "data3by4by1"),
  data4by1by2 %>% 
    as.data.frame() %>%
    mutate(category = "data4by1by2"),
  data1by2by3by4 %>%  
    as.data.frame() %>%
    mutate(category = "data1by2by3by4")
) %>% 
  full_join(full_data, by = c("."="elements")) %>% 
  rename(elements = ".") %>% 
  rbind(overlap_sizes %>% 
    filter(overlap_sizes == 0) %>% 
    mutate(elements = NA) %>% 
    mutate(values = NA) %>% 
    select(elements, category, values)) %>%    # this is the workaround for empty sets.
  mutate(category = factor(category, levels = rev(c(
    "data1_specific","data2_specific", "data3_specific", "data4_specific",
    "data1by2", "data1by3", "data1by4",
    "data2by3", "data2by4", "data3by4",
    "data1by2by3", "data2by3by4", "data3by4by1", "data4by1by2",
    "data1by2by3by4"
  )))) 

head(intersection_data) 
```


```{r}
farright_plot <- intersection_data %>% 
  mutate(log10sperm = log10(sperm)) %>% 
  ggplot(aes(x = category, y = log10sperm)) +
  geom_hline(yintercept = -Inf, size = 1.5) +
  geom_vline(xintercept = -Inf, size = 1.5) +
  geom_boxplot(outlier.shape  = NA, width = 0.7, fill = "skyblue1", alpha = 0.5) +
  theme_minimal()+
  scale_y_continuous() +
  scale_x_discrete(labels = NULL) +
  labs(y = "Sperm log10(RPM)",
       x = NULL) +
  theme_minimal() +
  theme(text = element_text(size = 14, face="bold"),
        axis.text.x=element_text(colour = "black"),
        axis.text.y=element_text(colour = "black")
        ) +
  coord_flip()

farright_plot

#in your actual data you can color the boxes or dots w/ factors of interest 
```


```{r}
#If you have empty sets the alignment won't be correct 

plot_grid(upperleft, upperright, NULL, 
          lowerleft, lowerright, farright_plot,  
          nrow = 2, 
          ncol = 3,
          rel_heights = c(1, 3),  
          rel_widths = c(0.8, 0.8, 1)) # the more stuff on the right, the thinner the left side has to be. 

ggsave("../Results/real_data_upset_extended.svg", height = 7, width = 6, bg = "white") 
# this time the plot needs to be wider
ggsave("../Results/real_data_upset_extended.png", height = 7, width = 6, bg = "white") 
```





